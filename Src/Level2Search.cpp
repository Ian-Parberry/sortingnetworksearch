/// \file Level2Search.cpp
/// \brief Code for the Level 2 search CLevel2Search.

// MIT License
//
// Copyright (c) 2022 Ian Parberry
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

#include <algorithm>

#include "Level2Search.h"

unsigned int CPUTimeInMilliseconds();

/// Perform a search for level 2 matchings and store them in lexicographic
/// order in m_stlResults. Print information to the console and the log file.

CLevel2Search::CLevel2Search(){
  printf("Searching for level 2 candidates on %d inputs.\n", INPUTS);
  size_t m_nCurIndex = 0; //index of current matching - no need to call GetIndex

  CMatching curMatching; //current matching

  do{ //for each matching
    if(odd(INPUTS))curMatching[INPUTS] = INPUTS; //dummy last channel for odd width networks
    CMatching copy(curMatching);

    if(m_stlUsed.find(m_nCurIndex) == m_stlUsed.end()){ //if it is not used
      const size_t minIndex = std::min(m_nCurIndex, Permute(copy, INPUTS/2)); //all pairwise permutations used also
     
      if(m_stlUsed.find(minIndex) == m_stlUsed.end()){ //if it is not used
        m_stlResults.push_back(curMatching); //insert into results
        m_stlUsed.insert(minIndex); //mark it used
      } //if
    } //if

    m_nCurIndex++; //index of next matching
  }while(curMatching.Next()); //get next matching, exit if there is none

  //print results except for the first one, which is the identity matching,
  //that is, identical to the first level in first normal form.

  const float t = CPUTimeInMilliseconds()/1000.0f;
  const size_t nNumLevel2 = m_stlResults.size() - 1; //not the identity matching
  printf("Found %zd candidates in %0.3f seconds.\n", nNumLevel2, t);

  //Log the running time.
  
  FILE* logfile = 0;
  fopen_s(&logfile, "log.txt", "at");

  if(logfile){
    fprintf_s(logfile, "%d inputs, %zd level 2 candidates in %0.3f seconds.\n",
      INPUTS, nNumLevel2, t);
    fclose(logfile);
  } //if

  //normalize the resulting matchings

  for(auto m: m_stlResults)
    m.Normalize();

  //sort the resulting matchings by index (not necessary but useful when debugging)
  
  std::sort(m_stlResults.begin(), m_stlResults.end());

  //print all but the first matching (the identity matching, which is identical
  //to matching for the the first level) to a file
  
  FILE* file = 0;
  fopen_s(&file, "level2.txt", "wt");

  if(file){
    for(auto p=std::next(m_stlResults.begin()); p!=m_stlResults.end(); p++)
      fprintf_s(file, "%s\n", ((std::string)*p).c_str());

    fclose(logfile);
  } //if
} //constructor

/// Given a matching, find the order in which it is generated by the matching
/// generation algorithm.
/// \param matching A perfect matching.
/// \return Order in which it is generated.

const size_t CLevel2Search::GetIndex(CMatching& matching) const{
  size_t index = 0; //the index value to be returned
  size_t b = GetNumMatchings(INPUTS)/(odd(INPUTS)? INPUTS: INPUTS - 1); //block size to be skipped
  size_t m[INPUTS + 1]; //local copy of matching to manipulate

  //grab a copy of matching into the array m

  for(size_t i=0; i<=INPUTS; i++)
    m[i] = matching[i];

  //make sure that each comparator is listed in ascending order

  for(size_t i=0; i<INPUTS; i+=2)
    if(m[i] > m[i+1])
      std::swap(m[i], m[i+1]);
  
  //compute index

  for(size_t n=odd(INPUTS)? INPUTS + 1: INPUTS; n>2; n-=2){ //for each comparator
    size_t max = 1; //the index of the largest channel on the max side of a comparator
    
    for(size_t i=1; i<=INPUTS; i+=2)
      if(m[i] > m[max])
        max = i;

    //skip over the matchings that have max matching to something smaller
    //than max is matching to in the current matching, which is m[max - 1]

    index += b*(n - 2 - m[max - 1]);

    //remove m[max - 1] from the matching

    for(size_t j=0; j<INPUTS; j++)
      if(m[j] > m[max - 1])m[j]--;

    //prepare for next iteration

    b /= n - 3; //block size to be skipped is now smaller
    m[max] = 0; //remove channel max from consideration
  } //for
  
  return index;
} //GetIndex

/// Find the minimum index over all permutations of pairs of
/// channels in a matching.
/// \param matching A matching.
/// \param n Size of permutation.
/// \return Smallest matching index from all permuted matchings.

size_t CLevel2Search::Permute(CMatching& matching, const size_t n){
  size_t nMinIndex = 99999; //minimum matching index found

  for(size_t i=0; i<n; i++){
    if(n > 2) //recurse on sub-permutation
      nMinIndex = std::min(nMinIndex, Permute(matching, n - 1));

    if(i < n - 1){ //base of recursion
      matching.Swap(odd(n)? 0: i, n - 1); //swap to new candidate
      nMinIndex = std::min(nMinIndex, GetIndex(matching));
    } //if
  } //for

  return nMinIndex;
} //Permute

///// Overloaded indexing operator.
///// \param n Index into the result vector.
///// \return const reference to the nth member of the result vector.
//
//const CMatching& CLevel2Search::operator[](const size_t n) const{
//  return m_stlResults[n];
//} //operator[]

/// Reader function for the vector of matchings.
/// \return Reference to the vector of matchings.

const std::vector<CMatching>& CLevel2Search::GetMatchings() const{
  return m_stlResults;
} //GetMatchings

/// Get number of matchings.
/// \param n Number of channels.
/// \return Number of matchings on n channels.

const size_t CLevel2Search::GetNumMatchings(const size_t n) const{
  size_t result = 1;

  for(size_t i = odd(n)? n: n - 1; i>1; i-=2)
    result *= i;

  return result;
} //GetNumMatchings