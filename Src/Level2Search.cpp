/// \file Level2Search.cpp
/// \brief Code for the Level 2 search `CLevel2Search`.

// MIT License
//
// Copyright (c) 2023 Ian Parberry
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

#include <algorithm>

#include "Level2Search.h"

/// Perform a search for level 2 matchings and store them in lexicographic
/// order in m_stlResults. Print information to the console and the log file.

CLevel2Search::CLevel2Search(){
  size_t m_nCurIndex = 0; //index of current matching - no need to call GetIndex

  CMatching curMatching; //current matching

  do{ //for each matching
    if(odd(m_nWidth))curMatching[m_nWidth] = m_nWidth; //dummy last channel for odd width networks
    CMatching copy(curMatching);

    if(m_stlUsed.find(m_nCurIndex) == m_stlUsed.end()){ //if it is not used
      const size_t minIndex = std::min(m_nCurIndex, Permute(copy, m_nWidth/2)); //all pairwise permutations used also
     
      if(m_stlUsed.find(minIndex) == m_stlUsed.end()){ //if it is not used
        m_stlResults.push_back(curMatching); //insert into results
        m_stlUsed.insert(minIndex); //mark it used
      } //if
    } //if

    m_nCurIndex++; //index of next matching
  }while(curMatching.Next()); //get next matching, exit if there is none

  //normalize the resulting matchings

  for(auto m: m_stlResults)
    m.Normalize();

  //sort the result matchings by index (not necessary but useful when debugging)
  
  std::sort(m_stlResults.begin(), m_stlResults.end());
} //constructor

/// Given a matching, find the order in which it is generated by the matching
/// generation algorithm.
/// \param matching A perfect matching.
/// \return Order in which it is generated.

size_t CLevel2Search::GetIndex(CMatching& matching){
  size_t index = 0; //the index value to be returned
  size_t b = GetNumMatchings(m_nWidth)/(oddfloor(m_nWidth)); //block size to be skipped

  //grab a copy of matching into the array m

  for(size_t i=0; i<=m_nWidth; i++)
    m_nCopy[i] = matching[i];

  //make sure that each comparator is listed in ascending order

  for(size_t i=0; i<m_nWidth; i+=2)
    if(m_nCopy[i] > m_nCopy[i+1])
      std::swap(m_nCopy[i], m_nCopy[i+1]);
  
  //compute index

  for(size_t n=evenceil(m_nWidth); n>2; n-=2){ //for each comparator
    size_t max = 1; //the index of the largest channel on the max side of a comparator
    
    for(size_t i=1; i<=m_nWidth; i+=2)
      if(m_nCopy[i] > m_nCopy[max])
        max = i;

    //skip over the matchings that have max matching to something smaller
    //than max is matching to in the current matching, which is m[max - 1]

    index += b*(n - 2 - m_nCopy[max - 1]);

    //remove m_nCopy[max - 1] from the matching

    for(size_t j=0; j<m_nWidth; j++)
      if(m_nCopy[j] > m_nCopy[max - 1])
        m_nCopy[j]--;

    //prepare for next iteration

    b /= n - 3; //block size to be skipped is now smaller
    m_nCopy[max] = 0; //remove channel max from consideration
  } //for
  
  return index;
} //GetIndex

/// Find the minimum index over all permutations of pairs of
/// channels in a matching.
/// \param matching A matching.
/// \param n Size of permutation.
/// \return Smallest matching index from all permuted matchings.

size_t CLevel2Search::Permute(CMatching& matching, const size_t n){
  size_t nMinIndex = 99999; //minimum matching index found

  for(size_t i=0; i<n; i++){
    if(n > 2) //recurse on sub-permutation
      nMinIndex = std::min(nMinIndex, Permute(matching, n - 1));

    if(i < n - 1){ //base of recursion
      matching.Swap(odd(n)? 0: i, n - 1); //swap to new candidate
      nMinIndex = std::min(nMinIndex, GetIndex(matching));
    } //if
  } //for

  return nMinIndex;
} //Permute

/// Reader function for the vector of matchings.
/// \return Reference to the vector of matchings.

const std::vector<CMatching>& CLevel2Search::GetMatchings() const{
  return m_stlResults;
} //GetMatchings

/// Get number of matchings.
/// \param n Number of channels.
/// \return Number of matchings on n channels.

const size_t CLevel2Search::GetNumMatchings(const size_t n) const{
  size_t result = 1;

  for(size_t i = oddfloor(n); i>1; i-=2)
    result *= i;

  return result;
} //GetNumMatchings